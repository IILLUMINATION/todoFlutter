import 'dart:convert';
//импорт либы конвертации
import 'dart:io';
//либа для работы с файлами

import 'package:path/path.dart'; as pathPackage;

import 'package:path_provider/path_provider.dart';
//пакет для получения дефолтного пути для хранения в разных системах

late final Directory _documentsDir;
//Directory это класс для работы с файлами берётся из dart io как и File
//объявляем late типо потом она будет финальную переменную для оптимизации где будет путь к директории документов дефолтной

//футуре объект который обязан в будущем чёто вернуть обязательно не как функция а именно
//футуре это типо сам по себе результат какой-то операции
//воид потому что не возвращает ничего, то есть нету return
//async показывает что всё что будет внутри функции будет обязательно асинхронным, функция с такой припиской всегда будет возвращать
//сама функция нужна чтобы в начале приложения файловую систему инициализировать
Future<void> initStorage() async {
  //объявляем переменную где будем хранить путь
  //используем await при вызове так как функция асинхронна и без эвэит из за отстуствия данных сразу выдаст ошибку тупо
  _documentsDir = await getApplicationDocumentsDirectory();
  print(
      "Стандартная директория на любой системе для документов: ${_documentsDir.path}");
}

//функция сохранения в файл json
//принимаем два обяхательных аругмента путь и дату
//Путь строкой, дата может быть любой, мы сконвертируем потом
//ставим тип что она async так как работа с файлами всегда такая
Future<void> saveToJson(String path, dynamic data) async {
  //try полезная штука, ЕЁ ВСЕГДА НУЖНО объявлять только внутри функции с типом async
  //имеет 4 типа, но чаще юзаются 2
  try {
    //вот здесь выполняем то что может выдать ошибку в теории

    //объявляем переменную и туда пишем класс File из дарт ио. Туда аргумент передаём путь.
    final file = File("${_documentsDir.path}/$path");
    //асинхронно записываем в наш файл через встроенный метод строку
    //в качестве строки то что передал юзер в функцию + конвертация в json
    await file.writeAsString(jsonEncode(data));
  } catch (e) {
    //обработка ошибки, просто отладочный принт
    print("ОшибОчка сохранения: $e");
  }
}

//аналогично прошлой функции
//типо динамик, так как вернуть вроде как я понял может что угодно типо мап а внутри разное
//аргумент дефолтного значения в {} значит необязательный
Future<dynamic> load(String path, {dynamic defaultValue}) async {
  try {
    final file = File("${_documentsDir.path}/$path");
    //проверяем через страндартный метод в File .exist что файл существует
    //если не существует вернём дефолтное значение
    if (!await file.exists()) {
      return defaultValue ?? {};
    }
    //контент в переменнюу и читаем это уже в случае если существует
    final contents = await file.readAsString();
    //возвращаем декодированный контент
    return jsonDecode(contents);
  } catch (e) {
    print("Ошибка уже чтения соотвественно, вот она: $e");
  }
}
